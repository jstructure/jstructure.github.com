<!DOCTYPE html>
<html lang="en">
<head>

  
  <meta charset="utf-8">
  <title>Расширение сущности Doctrine ORM</title>
  <meta name="description" content="Расширение сущности Doctrine ORM">
  <meta name="author" content="Albert Iskhakov">

  
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="http://jstructure.com/css/fonts.css">
  
  
  <link rel="stylesheet" href="https://unpkg.com/purecss@0.6.1/build/pure-min.css" integrity="sha384-CCTZv2q9I9m3UOxRLaJneXrrqKwUNOzZ6NGEUMwHtShDJ+nCoiXJCAgi05KfkLGY" crossorigin="anonymous">
  
  
    <link rel="stylesheet" href="https://unpkg.com/purecss@0.6.1/build/grids-responsive-min.css">
  
  <link rel="stylesheet" href="http://jstructure.com/css/custom.css">

  
  
  <link rel="stylesheet" href="http://jstructure.com/highlight/styles/default.css">
  
  <script src="http://jstructure.com/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <meta name="generator" content="Hugo 0.30.2" />
  
</head>
<body>

<div class="header pure-g">
    <div class="pure-u-1-24 pure-u-md-5-24"></div>
    <div class="pure-u-11-12 pure-u-md-5-8">
        <div class="desktop pure-menu pure-menu-horizontal nav-menu">
            
            <a href="http://jstructure.com/" class="site-title pure-menu-heading">jStructure</a>
            <ul class="pure-menu-list">
				
                <li class="pure-menu-item">
                    <a href="http://jstructure.com/about/" class="pure-menu-link">About</a>
                </li>
            </ul>
        </div>
        <div class="mobile pure-menu nav-menu">
            <a href="/" class="pure-menu-heading" id="toggle-home">jStructure</a>
            <a href="#" id="toggle-btn">&#9776;</a>
            <ul class="pure-menu-list" id="toggle-content" style="display:none;">
                
				
                <li class="pure-menu-item">
                    <a href="http://jstructure.com/about" class="pure-menu-link">About</a>
                </li>
            </ul>
        </div>
    </div>
    <div class="pure-u-1-24 pure-u-md-1-6"></div>
</div>

<div class="pure-g">
    <div class="pure-u-1-24 pure-u-md-5-24"></div>
	<div class="pure-u-11-12 pure-u-md-5-8">
        <div class="post">

            <div class="post-title">
                <p class="footnote">
                    <time class="">2017-11-13</time>
		            
                    
                    |
                    
                    
                    tags:<a href="http://jstructure.com/tags/doctrine">Doctrine</a> <a href="http://jstructure.com/tags/symfony">Symfony</a> <a href="http://jstructure.com/tags/php">PHP</a> <a href="http://jstructure.com/tags/sql">SQL</a> <a href="http://jstructure.com/tags/orm">ORM</a> 
                    

                    

                    
                </p>
                <h1>Расширение сущности Doctrine ORM</h1>
            </div>

            <div class="post-content">
                

<p>Иногда на практике бывает необходимо расширить сущности, передставляющие таблицы базы данных в коде.
Например, <a href="http://php.net">PHP</a>-фреймворк <a href="https://symfony.com">Symfony</a> позволяет создавать сущности в так называемых вендорных банлах. При необходимости в приложении, использующей этот бандл, можно расширить вендорную сущность свойствами, присущими предметной области данного приложения.
В статье рассматриваются различные варианты расширения сущностей на примере <a href="http://www.doctrine-project.org/projects/orm.html">Doctrine ORM</a> с использованием языка PHP.</p>

<h2 id="наследование-сущности-без-дополнительных-аннотаций">Наследование сущности без дополнительных аннотаций</h2>

<p>Начнем с рассмотрения простейшего случая расширения простым наследованием. Для этого создадим сущность <code>ParentEntity</code> и расширим его сущностью <code>ChildEntity</code>. В данном примере не будем использовать специальные аннотации <code>Doctrine</code>, используемые для расширения сущностей.</p>

<pre><code class="language-php">&lt;?php
// src/DataLayerBundle/Entity/ParentEntity.php

namespace DataLayerBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Table(name=&quot;parent_entity&quot;)
 */
class ParentEntity
{
    /**
     * @var int
     *
     * @ORM\Column(name=&quot;id&quot;, type=&quot;integer&quot;)
     * @ORM\Id
     * @ORM\GeneratedValue(strategy=&quot;AUTO&quot;)
     */
    protected $id;

    /**
     * @var string
     *
     * @ORM\Column(name=&quot;name&quot;, type=&quot;string&quot;, length=255)
     */
    protected $name;
}
</code></pre>

<p>Сущность <code>ParentEntity</code> содержит идентификатор и свойсво <code>$name</code>, которое является текстовым.</p>

<pre><code class="language-php">&lt;?php
// src/AppBundle/Entity/ChildEntity.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;
use DataLayerBundle\Entity\ParentEntity;

/**
 * @ORM\Table(name=&quot;child_entity&quot;)
 */
class ChildEntity extends ParentEntity
{
    /**
     * @var int
     *
     * @ORM\Column(name=&quot;name&quot;, type=&quot;integer&quot;)
     */
    protected $name;

    /**
     * @var int
     *
     * @ORM\Column(name=&quot;some_int&quot;, type=&quot;integer&quot;)
     */
    protected $someInt;
}

</code></pre>

<p>В дочерней сущности свойство <code>$name</code> базового класса переопределено на целочисленное, также добавлено новое свойство <code>$someInt</code>.
Создадим файл миграцию используя созданные сущности.</p>

<pre><code class="language-sh">$ php app/console doctrine:migrations:diff
</code></pre>

<pre><code class="language-php">// ...
$this-&gt;addSql('CREATE TABLE child_entity (id INT NOT NULL, name VARCHAR(255) NOT NULL, some_int INT NOT NULL, PRIMARY KEY(id))');
$this-&gt;addSql('CREATE TABLE parent_entity (id INT NOT NULL, name VARCHAR(255) NOT NULL, PRIMARY KEY(id))');
// ...
</code></pre>

<p>Исходя из полученных запросов можно сделать следующие выводы:</p>

<ol>
<li>под каждую сущность создается отдельная таблица;</li>
<li>сущность наследует свойства, определенные в родительской сущности;</li>
<li>для наследуемых свойств используются аннотации, определенные в родительском классе, даже если свойство было переопределено;</li>
<li>свойство, добавленное дочерней сущности, расширяет родительскую.</li>
</ol>

<h2 id="наследование-сущности-с-использованием-аннотации-mappedsuperclass">Наследование сущности с использованием аннотации <code>@MappedSuperclass</code></h2>

<p>Известно, что <em>Doctrine</em> представляет функционал <a href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/inheritance-mapping.html">наследования сущностей</a> с использованием специальных аннотаций.
В следующем примере попробуем использование аннотации <code>@MappedSuperclass</code> в базовом классе.</p>

<pre><code class="language-php">&lt;?php
// src/DataLayerBundle/Entity/ParentEntity.php

namespace DataLayerBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\MappedSuperclass
 */
class ParentEntity
{
    /**
     * @var int
     *
     * @ORM\Column(name=&quot;id&quot;, type=&quot;integer&quot;)
     * @ORM\Id
     * @ORM\GeneratedValue(strategy=&quot;AUTO&quot;)
     */
    protected $id;

    /**
     * @var string
     *
     * @ORM\Column(name=&quot;name&quot;, type=&quot;string&quot;, length=255)
     */
    protected $name;
}
</code></pre>

<p>Дочерний класс <code>ChildEntity</code> оставим без изменений.</p>

<p>В результате в файле миграций будет запрос на создание только дочерней таблицы.
Стоит обратть внимание, что поле <code>name</code> в запросе имеет тип <code>INT</code>, который был задан дочерним классом.</p>

<pre><code class="language-php">// ...
$this-&gt;addSql('CREATE TABLE child_entity (id INT NOT NULL, name INT NOT NULL, some_int INT NOT NULL, PRIMARY KEY(id))');
// ...
</code></pre>

<p>Напрашиваются следующие выводы:</p>

<ol>
<li>создается только таблица для дочерней сущности;</li>
<li>сущность наследует свойства, определенные в базовом классе;</li>
<li>дочерняя сущность переопределяет свойства, определенные в базовом класс.</li>
</ol>

<p>А теперь попробуем удалить дочерний класс, оставив при этом аннотацию <code>@MappedSuperclass</code> в базовом классе. Посмотрим, что будет в файле миграции? Как и следовало ожидать, там нет запросов.</p>

<h2 id="наследование-с-единой-таблицей-single-table-inheritance">Наследование с единой таблицей (Single Table Inheritance)</h2>

<p>Паттерн &laquo;Наследование с единой таблицей&raquo; <a href="https://martinfowler.com/eaaCatalog/singleTableInheritance.html">описан Мартиным Фаулером</a> в книге <a href="https://martinfowler.com/books/eaa.html">Patterns of Enterprise Application Architecture</a>.</p>

<p><img src="https://martinfowler.com/eaaCatalog/singleInheritanceTableSketch.gif" alt="Наследование с таблицами классов" /></p>

<p>Суть шаблона заключается в расположении полей нескольких классов в единой таблице СУБД.
К примеру, это способствует уменьшению количества JOIN&rsquo;ов при выборке данных из базы данных.
Для реализации этого подхода нужно создать родительский класс и аннотировать его следующими аннотациями:</p>

<ul>
<li><code>@InheritanceType</code> - указывает тип наследования</li>
<li><code>@DiscriminatorColumn</code> (опционально) - указывает столбец в таблице базы данных, в котором хранится информация о типе строки относительно иерархии классов</li>
<li><code>@DiscriminatorMap</code> (опционально) - указывает, какой записью в столбце <code>@DiscriminatorColumn</code> идентифицировать отпределнный тип</li>
</ul>

<p>В исходном коде аннотации <code>@InheritanceType</code> видно, что она может принимать значения: <code>NONE</code>, <code>JOINED</code>, <code>SINGLE_TABLE</code>, <code>TABLE_PER_CLASS</code>.</p>

<pre><code class="language-php">&lt;?php

namespace Doctrine\ORM\Mapping;

/**
 * @Annotation
 * @Target(&quot;CLASS&quot;)
 */
final class InheritanceType implements Annotation
{
    /**
     * The inheritance type used by the class and its subclasses.
     *
     * @var string
     *
     * @Enum({&quot;NONE&quot;, &quot;JOINED&quot;, &quot;SINGLE_TABLE&quot;, &quot;TABLE_PER_CLASS&quot;})
     */
    public $value;
}
</code></pre>

<p>Для реализации данного паттерна следует использовать <code>SINGLE_TABLE</code>.</p>

<p>Создадим необходимые классы.</p>

<pre><code class="language-php">&lt;?php
// src/DataLayerBundle/Entity/ParentEntity.php

namespace DataLayerBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity
 * @ORM\InheritanceType(&quot;SINGLE_TABLE&quot;)
 * @ORM\DiscriminatorColumn(name = &quot;discr&quot;, type = &quot;string&quot;)
 * @ORM\DiscriminatorMap({&quot;parent_entity&quot; = &quot;ParentEntity&quot;, &quot;child_entity&quot; = &quot;AppBundle\Entity\ChildEntity&quot;})
 */
class ParentEntity
{
    /**
     * @var int
     *
     * @ORM\Column(name=&quot;id&quot;, type=&quot;integer&quot;)
     * @ORM\Id
     * @ORM\GeneratedValue(strategy=&quot;AUTO&quot;)
     */
    protected $id;

    /**
     * @var string
     *
     * @ORM\Column(name=&quot;name&quot;, type=&quot;string&quot;, length=255)
     */
    protected $name;
}
</code></pre>

<p>Дочерний класс <code>ChildEntity</code> оставим без изменений.
В результате в файле миграций появится запрос на создание только одной таблицы <code>parent_entity</code>.</p>

<pre><code class="language-php">// ...
$this-&gt;addSql('CREATE TABLE parent_entity (id INT NOT NULL, name VARCHAR(255) NOT NULL, discr VARCHAR(255) NOT NULL, some_int INT DEFAULT NULL, PRIMARY KEY(id))');
// ...
</code></pre>

<p>Видно, что:</p>

<ol>
<li>создается только таблица для родительской сущности;</li>
<li>в таблицу попадают свойства, определенные в дочернем классе;</li>
<li>дочерняя сущность не переопределяет свойства, определенные в базовом класс.</li>
</ol>

<p>Попробуем выполниь миграцию и выполнить ввод данных через наши сущности, например, в контроллере.</p>

<pre><code class="language-php">// ...
$em = $this-&gt;get('doctrine.orm.entity_manager');

$parent = new ParentEntity();
$parent-&gt;setName('parent name');

$child = new ChildEntity();
$child-&gt;setSomeInt(9999999);
$child-&gt;setName('child name');

$em-&gt;persist($parent);
$em-&gt;persist($child);
$em-&gt;flush();
// ...
</code></pre>

<p>В результате в таблице появятся следующие записи:</p>

<pre><code class="language-sql">SELECT * FROM parent_entity;
</code></pre>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>discr</th>
<th>some_int</th>
</tr>
</thead>

<tbody>
<tr>
<td>1</td>
<td>parent name</td>
<td>parent_entity</td>
<td></td>
</tr>

<tr>
<td>2</td>
<td>child name</td>
<td>child_entity</td>
<td>9999999</td>
</tr>
</tbody>
</table>

<p>Если не писать аннотацию <code>@ORM\DiscriminatorMap({&quot;parent_entity&quot; = &quot;ParentEntity&quot;, &quot;child_entity&quot; = &quot;AppBundle\Entity\ChildEntity&quot;})</code> в родительском классе,
то значения в столбеце <code>discr</code> будут следующими:</p>

<pre><code class="language-sql">SELECT id, discr FROM parent_entity;
</code></pre>

<table>
<thead>
<tr>
<th>id</th>
<th>discr</th>
</tr>
</thead>

<tbody>
<tr>
<td>1</td>
<td>parententity</td>
</tr>

<tr>
<td>2</td>
<td>childentity</td>
</tr>
</tbody>
</table>

<h2 id="наследование-с-таблицами-классов-class-table-inheritance">Наследование с таблицами классов (Class Table Inheritance)</h2>

<p>Паттерн &laquo;Наследование с таблицами классов&raquo; также <a href="https://martinfowler.com/eaaCatalog/classTableInheritance.html">описан Мартиным Фаулером</a> в книге <a href="https://martinfowler.com/books/eaa.html">Patterns of Enterprise Application Architecture</a>.</p>

<p><img src="https://martinfowler.com/eaaCatalog/classInheritanceTableSketch.gif" alt="Наследование с таблицами классов" /></p>

<p>В отличии от паттерна &laquo;Наследование с единой таблицей&raquo; в данном подходе используется одна таблица на один класс в иерархии наследования.
Релизация отличается лишь значением аннотации <code>@InheritanceType</code>, которым в данном случае является <code>JOINED</code>.
Родительский класс будет выглядеть следующим образом.</p>

<pre><code class="language-php">&lt;?php
// src/DataLayerBundle/Entity/ParentEntity.php

namespace DataLayerBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity
 * @ORM\InheritanceType(&quot;JOINED&quot;)
 * @ORM\DiscriminatorColumn(name = &quot;discr&quot;, type = &quot;string&quot;)
 * @ORM\DiscriminatorMap({&quot;parent_entity&quot; = &quot;ParentEntity&quot;, &quot;child_entity&quot; = &quot;AppBundle\Entity\ChildEntity&quot;})
 */
class ParentEntity
{
    /**
     * @var int
     *
     * @ORM\Column(name=&quot;id&quot;, type=&quot;integer&quot;)
     * @ORM\Id
     * @ORM\GeneratedValue(strategy=&quot;AUTO&quot;)
     */
    protected $id;

    /**
     * @var string
     *
     * @ORM\Column(name=&quot;name&quot;, type=&quot;string&quot;, length=255)
     */
    protected $name;
}
</code></pre>

<p>Дочерний класс <code>ChildEntity</code> снова оставим без изменений.
В результате создадутся следующие запросы в файле миграций.</p>

<pre><code class="language-php">// ...
$this-&gt;addSql('CREATE TABLE child_entity (id INT NOT NULL, some_int INT NOT NULL, PRIMARY KEY(id))');
$this-&gt;addSql('CREATE TABLE parent_entity (id INT NOT NULL, name VARCHAR(255) NOT NULL, discr VARCHAR(255) NOT NULL, PRIMARY KEY(id))');
$this-&gt;addSql('ALTER TABLE child_entity ADD CONSTRAINT FK_677D8034BF396750 FOREIGN KEY (id) REFERENCES parent_entity (id) ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE');
// ...
</code></pre>

<p>Таким образом, создаются две таблицы, по одрной на каждую сущность из иерархии классов.
В каждой таблице находятся только поля, объявленные в соответсвующем классе сущности.
Стоит обратить внимание а то, что создается внешний ключ <code>child_entity.id -&gt; parent_entity.id</code>.
Произведем ввод данных, аналогичный предыдущему, и сделаем выборку данных из таблиц.</p>

<pre><code class="language-sql">SELECT * FROM parent_entity;
</code></pre>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>discr</th>
</tr>
</thead>

<tbody>
<tr>
<td>1</td>
<td>parent name</td>
<td>parent_entity</td>
</tr>

<tr>
<td>2</td>
<td>child name</td>
<td>child_entity</td>
</tr>
</tbody>
</table>

<pre><code class="language-sql">SELECT * FROM child_entity;
</code></pre>

<table>
<thead>
<tr>
<th>id</th>
<th>some_int</th>
</tr>
</thead>

<tbody>
<tr>
<td>2</td>
<td>9999999</td>
</tr>
</tbody>
</table>

<h2 id="тип-наследования-table-per-class">Тип наследования TABLE_PER_CLASS</h2>

<p>В аннотации <code>@InheritanceType</code> используем значение <code>TABLE_PER_CLASS</code>.</p>

<p>Выполняем команду для создания файла миграций и получаем <code>Doctrine\ORM\ORMException</code>:</p>

<pre><code>This behaviour is (currently) not supported by Doctrine 2
</code></pre>

<p>В документации <em>Doctrine</em> об этом типе ничего не сказано, но если обратиться к <a href="http://docs.jboss.org/hibernate/stable/annotations/reference/en/html_single/#d0e1191">документации Hibernate</a>,
то можно сделать вывод, что должны создаваться таблицы для каждой сущности. Причем каждая таблица содержит как свойства конкретной сущности, так и свойства всех родителей.
Судя по всему, тоже самое мы получим при аннотировании <code>@InheritanceType(&quot;NONE&quot;)</code>.</p>

<h2 id="тип-наследования-none">Тип наследования NONE</h2>

<pre><code class="language-php">$this-&gt;addSql('CREATE TABLE child_entity (id INT NOT NULL, name VARCHAR(255) NOT NULL, some_int INT NOT NULL, PRIMARY KEY(id))');
$this-&gt;addSql('CREATE TABLE parent_entity (id INT NOT NULL, name VARCHAR(255) NOT NULL, PRIMARY KEY(id))');
</code></pre>

            </div>
        </div>
	</div>
    <div class="pure-u-1-24 pure-u-md-1-6"></div>
</div>

<div class="footer pure-g">
    <div class="pure-u-1-24 pure-u-md-5-24"></div>
    <div class="pure-u-11-12 pure-u-md-5-8">
        <div class="footer-content">
		  <div class="pure-menu pure-menu-horizontal">
              <ul>
			      
                  <li class="pure-menu-heading" id="foot-name">Albert Iskhakov:</li>
                  
				  
                  
          
                  
          
                  
          
                  
          
                  
                  <li class="pure-menu-item">
                      <a href="https://twitter.com/aliskhakov" class="pure-menu-link">Twitter</a>
                  </li>
                  
          
              </ul>
              <a href="#" class="pure-menu-heading pull-right" id="gototop-btn">↑↑</a>
          </div>
		  
		</div>
	  </div>
      <div class="pure-u-1-24 pure-u-md-1-6"></div>
</div>


<script src="http://jstructure.com/js/jquery.min.js" type="text/javascript"></script>
<script src="http://jstructure.com/js/jquery.timeago.js" type="text/javascript"></script>
<script type="text/javascript">
  $(function(){
    $("time.timeago").timeago();
  })
  $("#toggle-btn").click(function(){
    $("#toggle-content").toggle();
    if($(this).html() === "☰") {
        $(this).html("X")
    } else {
        $(this).html("☰")
    }
  });
  $(window).resize(function(){
    if(window.innerWidth > 768) {
      $(".desktop").removeAttr("style");
    }
  });
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-109511104-1', 'auto');
  ga('send', 'pageview');
</script>

</body>
</html>

